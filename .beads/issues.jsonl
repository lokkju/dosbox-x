{"id":"DBX-09l","title":"QMP: Add save/load state commands","description":"Add QMP commands to save and load emulator state. Essential for automated testing checkpoints.\n\nProposed commands:\n```json\n{\"execute\": \"save-state\", \"arguments\": {\"filename\": \"/tmp/state.sav\"}}\n{\"execute\": \"load-state\", \"arguments\": {\"filename\": \"/tmp/state.sav\"}}\n```","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-18T19:20:59.87015942-08:00","updated_at":"2025-12-19T19:34:25.815513126-08:00","closed_at":"2025-12-19T19:34:25.815513126-08:00","close_reason":"Implemented savestate/loadstate QMP commands with host file support","labels":["feature","qmp"]}
{"id":"DBX-0q3","title":"QMP: Add screenshot to host file command","description":"Add a QMP command to capture the current screen to a file on the host. Useful for automated testing and verification.\n\nProposed command format:\n```json\n{\"execute\": \"screendump\", \"arguments\": {\"filename\": \"/tmp/screen.png\", \"format\": \"png\"}}\n```\n\nThis mirrors QEMU's screendump command.","design":"## Existing Functionality\n\nIn `src/hardware/hardware.cpp`:\n- `CAPTURE_ScreenShotEvent(true)` - sets capture flag, async capture on next frame\n- `CAPTURE_AddImage()` - called during render, writes PNG to capture directory\n- Global `pathscr` stores the last screenshot path\n- PNG format only, auto-numbered filenames\n\n## Challenge\n\nScreenshot is asynchronous - happens during next frame render. Need to:\n1. Trigger capture\n2. Wait for completion (poll or callback)\n3. Read file or return path\n\n## Implementation Plan\n\n1. Add `CAPTURE_ScreenShotToFile(const char* filepath)` that:\n   - Sets a specific output path instead of auto-generated\n   - Sets capture flag\n   - Returns immediately (async)\n2. Add `CAPTURE_IsCapturing()` to check if capture is pending\n3. Add QMP command `screendump` with arguments:\n   - `file`: output path (optional - if omitted, use temp file and return base64)\n4. QMP handler polls until capture completes, then returns\n\n## QMP Protocol\n\n```json\n{\"execute\": \"screendump\", \"arguments\": {\"file\": \"/tmp/screen.png\"}}\n{\"execute\": \"screendump\"}\n```\n\n## Alternative Simpler Approach\n\nJust trigger normal screenshot and return the auto-generated path from `pathscr`.","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-18T19:20:47.817127484-08:00","updated_at":"2025-12-19T18:18:09.694875945-08:00","closed_at":"2025-12-19T18:18:09.694875945-08:00","close_reason":"Implemented screendump QMP command with base64 return and file copy options","labels":["feature","qmp"]}
{"id":"DBX-18m","title":"Add integration tests for GDB/QMP servers","description":"Create external integration tests (Python scripts) that connect to the GDB and QMP servers and verify basic functionality. Avoids need for refactoring code for unit testability.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-17T00:29:09.2390112-08:00","updated_at":"2025-12-18T18:26:31.435886648-08:00","closed_at":"2025-12-18T18:26:31.435886648-08:00","close_reason":"Complete - Integration tests added for GDB server, QMP server, and video tools. 67 tests passing."}
{"id":"DBX-1p7","title":"QMP: Add mouse input commands","description":"Add QMP commands for mouse input injection. Useful for automating GUI interactions in DOS/Windows applications.\n\nProposed commands:\n```json\n{\"execute\": \"mouse-move\", \"arguments\": {\"x\": 100, \"y\": 200, \"absolute\": true}}\n{\"execute\": \"mouse-button\", \"arguments\": {\"button\": \"left\", \"down\": true}}\n```\n\nCould also support QEMU's input-send-event format for mouse events.","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-18T19:20:54.277261271-08:00","updated_at":"2025-12-18T19:20:54.277261271-08:00","labels":["feature","qmp"]}
{"id":"DBX-3da","title":"Rename C_GDBSERVER to C_REMOTEDEBUG","description":"Rename the build flag from C_GDBSERVER to C_REMOTEDEBUG to better reflect that it covers both GDB remote debugging and QMP keyboard input protocols.","status":"closed","priority":1,"issue_type":"chore","created_at":"2025-12-16T22:32:20.413564306-08:00","updated_at":"2025-12-16T22:41:32.354244916-08:00","closed_at":"2025-12-16T22:41:32.354244916-08:00","close_reason":"Renamed C_GDBSERVER to C_REMOTEDEBUG across all files","dependencies":[{"issue_id":"DBX-3da","depends_on_id":"DBX-mbt","type":"blocks","created_at":"2025-12-16T22:32:20.414630321-08:00","created_by":"daemon"}]}
{"id":"DBX-82p","title":"QMP: Add memory dump to host file command","description":"Add a QMP command to dump a range of emulated memory to a file on the host system. Useful for debugging and automated testing.\n\nProposed command format:\n```json\n{\"execute\": \"dump-memory\", \"arguments\": {\"start\": 0xB8000, \"length\": 4000, \"filename\": \"/tmp/videomem.bin\"}}\n```","design":"## Existing Functionality\n\nIn `src/debug/debug.cpp`:\n- `SaveMemoryBin(uint16_t seg, uint32_t ofs1, uint32_t num)` - static function, writes raw binary to MEMDUMP.BIN\n- `SaveMemory(uint16_t seg, uint32_t ofs1, uint32_t num)` - static function, writes hex dump to MEMDUMP.TXT\n- `DEBUG_ReadMemory(uint32_t address)` - public, reads one byte (too slow for large dumps)\n\n## Implementation Plan\n\n1. Create public wrapper `DEBUG_SaveMemoryBin(const char* filepath, uint32_t address, uint32_t size)` in debug.cpp\n2. Add QMP command `memdump` with arguments:\n   - `address`: linear address (required)\n   - `size`: bytes to dump (required)\n   - `file`: output path (optional - if omitted, use temp file and return base64)\n3. Return format:\n   - With file: `{\"file\": \"/path/to/file\", \"size\": N}`\n   - Without file: `{\"data\": \"\u003cbase64\u003e\", \"size\": N}`\n\n## QMP Protocol\n\n```json\n{\"execute\": \"memdump\", \"arguments\": {\"address\": 0, \"size\": 65536, \"file\": \"/tmp/dump.bin\"}}\n{\"execute\": \"memdump\", \"arguments\": {\"address\": 0, \"size\": 1024}}\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-18T19:20:41.328728638-08:00","updated_at":"2025-12-19T09:42:01.878534096-08:00","closed_at":"2025-12-19T09:42:01.878534096-08:00","close_reason":"Implemented memdump QMP command with base64 return and file save options","labels":["feature","qmp"]}
{"id":"DBX-83n","title":"QMP: Add emulator control commands (pause/resume/reset)","description":"Add QMP commands for basic emulator control.\n\nProposed commands:\n```json\n{\"execute\": \"stop\"}        // Pause emulation\n{\"execute\": \"cont\"}        // Resume emulation  \n{\"execute\": \"system_reset\"} // Reset the emulated system\n{\"execute\": \"quit\"}        // Exit DOSBox-X (already partially supported)\n```\n\nThese mirror QEMU's control commands.","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-18T19:21:06.27390548-08:00","updated_at":"2025-12-20T12:48:30.350515207-08:00","closed_at":"2025-12-20T12:48:30.350515207-08:00","close_reason":"Implemented stop, cont, system_reset, and query-status QMP commands. All tests passed.","labels":["feature","qmp"]}
{"id":"DBX-ard","title":"QMP: Add base64 data transfer for savestate/loadstate","description":"Add optional base64 data transfer support to savestate/loadstate commands for remote state management.\n\nCurrently savestate/loadstate only support host file paths. For remote automation scenarios (CI/CD pipelines, remote debugging), it would be useful to transfer state data directly via base64 encoding, similar to how memdump and screendump work.\n\nProposed enhancement:\n- If no `file` argument given to savestate, return state as base64 in response\n- If `data` argument given to loadstate instead of `file`, accept base64 state data\n\nNote: State files can be large (100KB+), so this is lower priority than file-based operations.","status":"open","priority":4,"issue_type":"feature","created_at":"2025-12-19T19:34:19.888945815-08:00","updated_at":"2025-12-19T19:34:19.888945815-08:00","labels":["enhancement","feature","qmp"]}
{"id":"DBX-azs","title":"GDB server handshake fails with dbxdebug client","description":"When connecting with dbxdebug 0.2.1 Python client, the GDB server logs:\n```\nGDBServer: Client connected\nGDBServer: Unexpected initial packet - \nGDBServer: Handshake failed\n```\n\nThe client sends a valid qSupported packet with correct checksum, but the server receives an empty string. This suggests either:\n1. Checksum mismatch causing receive_packet() to return \"\"\n2. Some bytes being lost/corrupted in transmission\n3. Encoding issue between Python bytes and C++ char","design":"Investigation needed:\n1. Add LOG_DEBUG output in receive_packet() to show raw bytes received\n2. Log the calculated vs received checksum values\n3. Test with raw telnet/netcat to isolate client vs server issue\n4. Compare with GDB proper to see if it works","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-18T16:49:20.439712671-08:00","updated_at":"2025-12-18T18:12:41.398395404-08:00","closed_at":"2025-12-18T18:12:41.398395404-08:00","close_reason":"Fixed - was caused by noack_mode persisting between client connections; now reset on disconnect","labels":["gdbserver","handshake"]}
{"id":"DBX-k6u","title":"GDB server crashes on toggle due to use-after-free","description":"DEBUG_StopGDBServer() deletes gdbServer immediately after calling stop(), but the detached server thread is still running and will access freed memory when its blocking accept()/read() call returns.\n\nThe crash occurs when toggling Debug \u003e GDB Server menu item while a client was connected or the server is blocked.","design":"Fix options:\n1. Use a joinable thread instead of detached, call join() after stop()\n2. Add a condition variable for clean shutdown signaling\n3. Use shared_ptr or ensure thread exits before delete\n\nRecommended: Option 1 - change to joinable thread:\n- Store std::thread in GDBServer class\n- Add join() method that waits for thread to exit\n- In stop(), set running=false, close sockets (unblocks thread), then join\n- Call join() from DEBUG_StopGDBServer() before delete","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T16:49:20.31226014-08:00","updated_at":"2025-12-18T18:12:41.183242695-08:00","closed_at":"2025-12-18T18:12:41.183242695-08:00","close_reason":"Fixed - server thread is now joinable and stop() waits for it to exit before deleting the object","labels":["crash","gdbserver","threading"]}
{"id":"DBX-mbt","title":"Implement QMP-compatible keyboard input protocol","description":"Add a QEMU QMP-compatible protocol for keyboard input injection, separate from the GDB stub. This allows use of existing QEMU tooling and provides a cleaner separation of concerns.\n\nKey components:\n- JSON-based protocol on separate socket\n- send-key command with hold-time support\n- input-send-event for explicit press/release control\n- QKeyCode-compatible key names mapped to DOSBox KBD_KEYS","design":"## Protocol Design\n\nUse QEMU's QMP subset:\n- `send-key`: Array of keys pressed simultaneously, auto-release after hold-time\n- `input-send-event`: Explicit key down/up events\n\n## Key Name Mapping\n\nMap QEMU QKeyCode names to DOSBox KBD_KEYS enum values via static lookup table.\n\n## Implementation Plan\n\n1. Create `include/qmp.h` - QMPServer class declaration\n2. Create `src/debug/qmp.cpp` - QMP server implementation\n   - Socket handling (reuse pattern from gdbserver)\n   - JSON parsing (minimal, just what we need)\n   - Key mapping table\n   - send-key command\n   - input-send-event command\n3. Update `src/debug/Makefile.am` - add qmp.cpp\n4. Update `configure.ac` - gate behind C_QMPSERVER or reuse C_GDBSERVER\n5. Update `src/dosbox.cpp` - add qmp config options\n6. Update `src/debug/debug.cpp` - startup/shutdown\n7. Update docs/GDBSERVER.md or create docs/QMP.md","notes":"Implementation complete. QMP server with send-key and input-send-event commands. Renamed C_GDBSERVER to C_REMOTEDEBUG. Documentation updated.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-16T22:23:09.068905908-08:00","updated_at":"2025-12-16T22:43:39.476902161-08:00","closed_at":"2025-12-16T22:43:39.476902161-08:00","close_reason":"QMP keyboard input protocol implemented and documented"}
{"id":"DBX-o39","title":"Debug server menu checkmarks don't reflect actual state","description":"The Debug menu items for GDB Server and QMP Server should show checkmarks that properly reflect whether each server is currently running.\n\nNeed to verify:\n1. Checkmark appears when server is started\n2. Checkmark disappears when server is stopped\n3. State is correct on initial load based on config settings","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-18T18:17:44.137113821-08:00","updated_at":"2025-12-18T18:31:28.267747543-08:00","closed_at":"2025-12-18T18:31:28.267747543-08:00","close_reason":"Fixed - menu checkmarks now update on startup and after toggling","labels":["gdbserver","menu","qmpserver","ui"]}
{"id":"DBX-z6v","title":"GDB step/continue don't execute from separate thread","description":"DEBUG_Step() and DEBUG_Continue() call DEBUG_CheckKeys() to simulate F11/F5 keypresses in the debugger, but when called from the GDB server thread, the main emulator loop doesn't process them.\n\nResult: step command returns S05 response but EIP doesn't change - the instruction isn't actually executed.\n\nThis is a threading/synchronization issue between the GDB server thread and the main emulator thread.","design":"Options:\n1. Use a condition variable or event to signal the main thread to execute step/continue\n2. Have the GDB server set a flag that the main loop checks\n3. Use SDL events to communicate with main thread\n4. Refactor debugger to be thread-safe\n\nThe proper fix likely requires main loop integration rather than just simulating keypresses.","notes":"Implemented direct execution path for step/continue when GDB server is running. Needs testing to verify it works correctly.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-18T18:10:20.693056402-08:00","updated_at":"2025-12-19T08:42:21.957448154-08:00","closed_at":"2025-12-19T08:42:21.957448154-08:00","close_reason":"Fixed: Implemented thread-safe step/continue with proper synchronization between GDB server thread and main emulator loop. All 23 GDB server tests now pass.","labels":["gdbserver","threading"]}
